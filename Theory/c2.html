<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="../elements/favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:
ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;
1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
 rel="stylesheet"> <!--this the font for heading1-->
 <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;
0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;
1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Work+Sans:ital,wght@0,100..
900;1,100..900&display=swap" rel="stylesheet"><!--this the font for heading3-->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Share+Tech+Mono&display=swap"
 rel="stylesheet"><!--this the font for heading2-->
 <link href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"><!--this the font for theoryicon-->
              <style>
              h2 {
                font-size: 40px;
                font-family: "Share Tech mono";
                margin: 50px;
                word-wrap: break-word;
                white-space: normal;
                color: #0e1111;
            }
            a{
                text-decoration: none;
                color: #ffffff;
            }

                html,body{
                 padding:0px;
                 margin:0px;
                }
    h1{
        font-family: Poppins;
        color: #0C96FF;
        }
        table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      text-align: center;
      margin-left: auto;
      margin-right: auto;
    }
        </style>
    <title>Hardware and software</title>
</head>
<body style="background-color: #ece0d1; display: flex; flex-direction: column;">
    <div style="background-color: #065473;">
        <p class="header" style="color: white; font-size: 15px; 
         margin-top: 20px; margin-left: 20px; font-family: Poppins;">
         <a href="../index.html" style="text-decoration: none; color: #ffffff;">
            Home</a>&nbsp&nbsp&nbsp<a href="../aboutme.html">About me</a></p>
        <h1 style="text-align: center;"><a href="../index.html" style="text-decoration:none; color: #ffffff; ">
            ITpastabowl<i class="material-icons">
            rice_bowl </i></a></h1>
    <h3 style="text-align: center; color: #0C96FF; font-family: Work sans;">9626 Information Technology study
         material.©</h3></div>


         <span style="font-family: work sans;"><p style="font-family: work sans; margin-left: 30px;"><p>
            <h1>Hardware and software</h1>
            <h1>Software</h1>
            <B>Software</B> are programs which give instructions to the computer<Br><Br>
            <b>System software:</b>Programs that are used to maintain a computer system are known as utility system softwares.<br>
            (disk defragmentation, deleting data, anti virus)<Br><br>
            <B>Application software</B> is software that helps users complete a task. (word processing, spreadsheets etc)<Br><Br>
            <h1>Operating system</h1>
            <b>Operating system</b>  is the software that is needed to <i>operate a computer system</i>.<Br>
             It sits between hardware and applications software and manages the communication between the two.<Br>
            It manages the hardware by carrying out tasks such as:<br><ul>
           <li> Allocating memory to software</li>
           <li> Sending data and instructions to output devices</li>
           <li> Responding to input devices when an input is given</li>
           <li> Allocating processor tasks -etc</li>
        </ul>
            
            <b>Device driver</b> is the software that comes with an external hardware component and sends customised instructions<Br>
             to that specific component. Acts as a middleman between hardware and software<br>
            
            <h1>Translators</h1>
           <b>Compiler:</b> <i>Converts source code into object code by creating an executable</i>. When the program is compiled<Br>
            the entirety of the source code is translated into the executable file at once
            and then can be distributed to resellers,<Br> customers and individual computers. Keep in mind that once compiled,
             <mark> program will run only on the operating system it was compiled for</mark>.<Br><br>
                <img src="../elements/Compiler_Interpreter.png.webp" alt="working of compiler and interpreter" style="width: 600px; 
                margin-left: auto; margin-right: auto; display: block;">
            <b>3 stages of compilation</b><ul>
            <li><B>Lexical analysis:</B>  All white spaces, comments will be removed and the code will be broken into tokens</li>
            <li><B>Syntax analysis:</B> During syntax analysis the structure of the program will be analysed
             to check that it conforms<Br> to the syntax of the programming language. All the tokens will be analysed individually.</li>
            <li><B> Code generation:</B> During this phase, the source code is converted into machine code for the target machine type.</li>
        </ul>
            
            <b>Interpreters</b> also translate a program from high level language into machine code. <mark> a compiler they translate the code one line at a time</mark>.<Br>
             It translates each line of the source code into an intermediate stage and then<Br>
             executes the line of code, reporting errors as each line is translated.
            <Table>
                <Tr><td colspan="2"><b>Compiler</b></td></Tr>
                <tr><td><i>Advantages</i></td>
                    <td><i>Disadvantages</i></td>
                </tr>
                <tr>
                    <td>Translates source code into object code all<Br> at once in advance of execution</td>
                    <td>Compiled object code will only work on the <Br>operating system it has been compiled for</td>
                </tr>
                <tr>
                    <td>Object code is ready to be executed without delay</td>
                    <td>Compiling can take a long time, which is not<Br> appropriate for on the fly testing</td>
                </tr>
                <tr>
                    <td>Errors are reported after<Br> compilation has completed</td>
                    <td>The source code is optimised<Br> to run as efficiently as possible</td>
                </tr>

            </Table>       <Br><br>
            <Table>
                <Tr><td colspan="2"><b>Interpreter</b></td></Tr>
                <tr><td><i>Advantages</i></td>
                    <td><i>Disadvantages</i></td>
                </tr>
                <tr>
                    <td>Source code can be translated into object<Br> code for more than one operating system</td>
                    <td>Translates source code into object code one line at a time</td>
                </tr>
                <tr>
                    <td>Only the required code needs to be interpreted<Br> so this is efficient for quick testing</td>
                    <td>Object code has to be generated so additional time <Br>is added to the execution time</td>
                </tr>
                <tr>
                    <td>Errors are reported as they are found</td>
                    <td></td>
                </tr>

            </Table><br><Br>
            
           <b> Linkers</b>
            Computer programs often consist of several <u style="cursor: pointer;" title="technique that separates the functionality of a program into independent, interchangeable modules">
            modules</u>. Each module carries out a specific task.<Br>
             After the compilation process there will remain multiple pieces of object code. The linker will
             take these pieces and then <Br><mark>combine them into one single executable file</mark>.<Br><br>
                <Table>
                    <Tr><td colspan="2"><b>Linker</b></td></Tr>
                    <tr><td><i>Advantages</i></td>
                        <td><i>Disadvantages</i></td>
                    </tr>
                    <tr>
                        <td>Writing programs in modules means they require less ram<Br>
                            Saving memory costs</td>
                        <td>Variable names can cause problems</td>
                    </tr>
                    <tr>
                        <td>The program and compiler don’t need to be<Br> in memory at the same time</td>
                        <td>Documentation has to be written more in detail</td>
                    </tr>
                    <tr>
                        <td>If there Is a problem in a module only that<Br> module needs to be corrected</td>
                        <td></td>
                    </tr>
                </Table><br><Br>
                        
           <h1> Utility software</h1>
            <B>Anti-virus:</B>
            Also known as <i>anti malware</i>, has two main functions. The first is <i>an anti-virus monitor</i> that is continually monitoring
             the system for<Br> viruses and malware. If it detects any unusual
            behaviour or signs of viruses or malware then
            it will <mark> them<Br> from being executed</mark> so they cannot
            cause damage to any files. The second function
            is to check for <I>viruses or malware that<Br> may already
            be on a system</I>. Known as scanning the
            system. If anything is found then the user will usually
            be given the option to disinfect<Br> the affected area,
            put it into quarantine or ignore it.<Br><Br>
            
            <b>Disk defragmentation:</b> A hard disk drive (HDD) is build up of multiple disks and a read/write head.<Br>
             When files are deleted, gaps are created on the disk. As files grow, they use up space on the disk, and this space<Br>
             may not be contiguous. As a result, files can be spread across many clusters. If gaps are too small, files may be split,<Br>
             causing fragmentation. Fragmentation slows down file access because the hard drive's access arm must move to different<br>
             locations when opening the file. Wherever possible, a computer will attempt<Br>
            to store data in clusters on a single cylinder because this
            requires the least access arm movement.<Br> This can significantly increase speeds and <span style="color: #0C96FF;"> fetch data quicker</span>.<Br>

            <img src="../elements/Disk_Defragmentation.png" alt="Disk defragmentation chart" style="width: 400px; margin-left:
             auto; margin-right: auto; display: block;"><br><Br>
            <h1>Custom-written software and off-the-shelf software</h1>
            <B>Custom-written software:</B> software that is written especially to meet the requirements of a client<br><Br>
            <b>Off-the-shelf software:</b> general purpose software available to a large market
            
                <Table>
                <Tr><td colspan="2"><b>Custom written</b></td></Tr>
                <tr><td><i>Advantages</i></td>
                    <td><i>Disadvantages</i></td>
                </tr>
                <tr>
                    <td>The requirements of the client can be met<Br>
                     precisely with no features that are not necessary</td>
                    <td>The entire development cost of the software is met<Br>
                     by the client which makes it very expensive.</td>
                </tr>
                <tr>
                    <td>The developers of the software will ensure<Br>
                     that the software is compatible with the hardware,<br>
                    software and data used by the client</td>
                    <td>Software takes a very long time to develop</td>
                </tr>
                <tr>
                    <td>The client will have access to support from <Br>
                    the company that developed the software</td>
                    <td>It is likely that many bugs will be found while being used</td>
                </tr>
            </Table><br><Br>
                <Table>
                    <Tr><td colspan="2"><b>Off the shelf</b></td></Tr>
                    <tr><td><i>Advantages</i></td>
                        <td><i>Disadvantages</i></td>
                    </tr>
                    <tr>
                        <td>Cost of software is spread between all the<Br> customers which means the cost is much lower.</td>
                        <td>Some tasks that the needed to be carried out<Br> may not be possible and there<Br>
                         will be lots of unrequired features..</td>
                    </tr>
                    <tr>
                        <td>Off-the-shelf software is immediately<Br> available for the customer</td>
                        <td>software may not be compatible with existing hardware.</td>
                    </tr>
                    <tr>
                        <td>bugs will have been identified<Br> and fixed, and patches<Br> will be released as more bugs are found</td>
                        <td>May have compatibility issues</td>
                    </tr>
                </Table><br><Br>  
            <B>Open source:</B> software has the <mark> code freely available</mark>. It can be freely accessed,
             used, changed or shared.<br> There is often a community of developers that contribute to the development
             of open source software<Br><Br>
        
            <b>Proprietary software</b> is owned by a single person or organisation who sells it for use under an agreed licence.<Br>
             The software <mark> only the essential files for its operation</mark>, while the owner keeps the source code used<Br>
             in its creation. Various licenses can be issued for software usage, such as freeware, shareware,
             single-user, multi-user, and site licenses.<Br><Br>
            
            <h1>Hardware</h1>
            <B>Hardware devices</B> are the physical components of a computer.<br><Br>
            <b>Input Device:</b> a device that allows data to be entered to a computer system.<Br><br>
            <b>Output Devices:</b> a device used to communicate data or information from a computer system.<Br>
            <h1>CPU</h1>
            <b>Central Processing Unit (CPU):</b> the CPU carries out the calculations, executes instructions and processes data.<Br>
             The CPU consists of an <u style="cursor: pointer;" title="Arithmetic Logical Unit">ALU</u> and the
             <u style="cursor: pointer;" title="Control unit">CU</u>.
            <B><I>Arithmetic Logical Unit (ALU):</I></B> Performs Calculations and logical operations.<Br><br>
            <B><I>Control Unit:</I></B> The CU runs the fetch-execute cycle which fetches instructions from memory and executes them.<Br><br>
            The CPU also contains small memory units known as <u style="cursor: pointer;" title="used to store and manipulate data during the execution of instructions">registers</u>.
            <b>RAM (Random Access Memory):</b> Memory used to store currently active programs and volatile data.<Br><Br>
            <B>ROM (Read-Only Memory):</B> The memory that, once written to cannot be removed and can only be read (involatile).<Br>
             ROMs usually store the <u style="cursor: pointer;" title="Basic input output system">BIOS</u> of a system.<Br>

            <h1>Mainframe vs Supercomputers</h1>
            <B>Mainframe computer:</B> powerful computer serving several terminals. They are also used for large scale<Br>
             transaction processing and batch processing. Other uses include statistical analysis such as analysis of census data.<Br>
             Mainframe computers need to have reliability, availability and serviceability (<mark>RAS</mark>) characteristics.<Br>
             For <mark>reliability</mark>, hardware components must self-check and recover from failures. Mainframe software<Br>
             undergoes thorough testing and can be quickly updated if issues arise. To ensure continuous operation,<Br>
             the mainframe has redundant hardware like storage and power supplies, making it <mark>accessible</mark><Br>
             If an active component fails, the redundant ones automatically take over.<Br>
             This allows replacing a failed component with a new one without disrupting the mainframe's functionality,<Br>
             making it easily <mark>serviceable</mark><Br><Br>
            <b>Supercomputer:</b> large computer with parallel processing to complete highly complex tasks quickly.<Br>
             Supercomputers are crafted for performing numerous complicated calculations quickly. They typically execute<Br>
             a limited number of programs, concentrating on swiftly processing instructions for a specific purpose. They will be <mark><Br>
             at maximum capacity</mark> so that their full power is used to process data and solve a problem.
            <h1>Performance metrics</h1>
            Mainframe computer performance is traditionally assessed by the number of instructions its processors execute per second,<Br>
             measured in <u>MIPs (millions of instructions per second)</u>. However, this metric <mark> not very accurate</mark><Br>
             due to other <u style="cursor: pointer;" title="a factor not being investigated but has the potential to impact the outcome of a study">extraneous variables</u>.
             <u>CISC (complex instruction set computing)</u> processors perform multiple tasks in a single instruction, <Br>
            while <u>RISC (reduced instruction set computing)</u> processors will have a single instruction that does very little<Br>
             but manages the instruction efficiently.<Br><Br>
            
            Another metric for assessing performance is <u>FLOPS (floating-point operations per second)</u>,<Br>
             or <U>MFLOPS (mega floating-point operations per second)</U>.
            Floating-point instructions are common in scientific computational research,<Br>
             and MFLOPS (mega floating-point operations per second) are frequently used to compare supercomputer speeds.<Br>
             MFLOPS provide a more reliable performance measure than MIPS, though discrepancies exist.<Br>
             Some processors may complete a single floating-point operation, while others might need several for the same result.
            
            
            
            
        </p></span>
    
</body>
</html>